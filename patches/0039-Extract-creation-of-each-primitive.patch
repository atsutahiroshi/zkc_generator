From 2381a49e5d26b1b4361314644bdff70c233d0ae0 Mon Sep 17 00:00:00 2001
From: Hiroshi Atsuta <atsuta.hiroshi@gmail.com>
Date: Thu, 12 Oct 2017 15:40:25 +0200
Subject: [PATCH 39/41] Extract creation of each primitive

---
 src/RokiPlugin/RokiSimulatorItem.cpp | 108 +++++++++++++++++++++++------------
 1 file changed, 70 insertions(+), 38 deletions(-)

diff --git a/src/RokiPlugin/RokiSimulatorItem.cpp b/src/RokiPlugin/RokiSimulatorItem.cpp
index b20cbc5..c8b5c11 100644
--- a/src/RokiPlugin/RokiSimulatorItem.cpp
+++ b/src/RokiPlugin/RokiSimulatorItem.cpp
@@ -220,6 +220,10 @@ private:
 
     string createShapeName();
     bool canBeCreatedAsPrimitive(SgMesh* mesh);
+    void createAsBox(SgMesh* mesh, const Affine3& T0, const Vector3& p, const Vector3& scale);
+    void createAsSphere(SgMesh* mesh, const Affine3& T0, const Vector3& p, const Vector3& scale);
+    void createAsCylinder(SgMesh* mesh, const Affine3& T0, const Affine3& T_, const Vector3& p, const Vector3& scale);
+    void createAsCone(SgMesh* mesh, const Affine3& T0, const Affine3& T_, const Vector3& p, const Vector3& scale);
     void createAsPrimitive(SgMesh* mesh);
     void createAsPolyhedron(SgMesh* mesh);
 };
@@ -640,6 +644,60 @@ bool RokiVisualShape::canBeCreatedAsPrimitive(SgMesh* mesh)
 }
 
 
+void RokiVisualShape::createAsBox(SgMesh* mesh, const Affine3& T0, const Vector3& p, const Vector3& scale)
+{
+    const Vector3& s = mesh->primitive<SgMesh::Box>().size;
+    zVec3D zp, ax, ay, az;
+
+    zVec3DCreate(&zp, p.x(), p.y(), p.z());
+    zVec3DCreate(&ax, T0(0,0), T0(1,0), T0(2,0));
+    zVec3DCreate(&ay, T0(0,1), T0(1,1), T0(2,1));
+    zVec3DCreate(&az, T0(0,2), T0(1,2), T0(2,2));
+    zShape3DCreateBox(&shape_, &zp, &ax, &ay, &az,
+                      s.x()*scale.x(), s.y()*scale.y(), s.z()*scale.z());
+}
+
+
+void RokiVisualShape::createAsSphere(SgMesh* mesh, const Affine3& T0, const Vector3& p, const Vector3& scale)
+{
+    SgMesh::Sphere sphere = mesh->primitive<SgMesh::Sphere>();
+    zVec3D zp;
+
+    zVec3DCreate(&zp, p.x(), p.y(), p.z());
+    zShape3DCreateSphere(&shape_, &zp, sphere.radius*scale.x(), 0);
+}
+
+
+void RokiVisualShape::createAsCylinder(SgMesh* mesh, const Affine3& T0, const Affine3& T_, const Vector3& p, const Vector3& scale)
+{
+    SgMesh::Cylinder cylinder = mesh->primitive<SgMesh::Cylinder>();
+    Vector3 ax(T_(0,0), T_(1,0), T_(2,0));
+    ax *= cylinder.height/2.0 * scale.x();
+    Vector3 c1_ = T0 * ax.cast<Position::Scalar>();
+    Vector3 c2_ = T0 * (-ax).cast<Position::Scalar>();
+    zVec3D c1, c2;
+
+    zVec3DCreate(&c1, c1_.x(), c1_.y(), c1_.z());
+    zVec3DCreate(&c2, c2_.x(), c2_.y(), c2_.z());
+    zShape3DCreateCyl(&shape_, &c1, &c2, cylinder.radius*scale.x(), 0);
+}
+
+
+void RokiVisualShape::createAsCone(SgMesh* mesh, const Affine3& T0, const Affine3& T_, const Vector3& p, const Vector3& scale)
+{
+    SgMesh::Cone cone = mesh->primitive<SgMesh::Cone>();
+    Vector3 ax(T_(0,0), T_(1,0), T_(2,0));
+    ax *= cone.height/2.0 * scale.x();
+    Vector3 c1_ = T0 * ax.cast<Position::Scalar>();
+    Vector3 c2_ = T0 * (-ax).cast<Position::Scalar>();
+    zVec3D c1, c2;
+
+    zVec3DCreate(&c1, c1_.x(), c1_.y(), c1_.z());
+    zVec3DCreate(&c2, c2_.x(), c2_.y(), c2_.z());
+    zShape3DCreateCone(&shape_, &c1, &c2, cone.radius*scale.x(), 0);
+}
+
+
 void RokiVisualShape::createAsPrimitive(SgMesh* mesh)
 {
     Affine3 T = currentTransform;
@@ -659,44 +717,18 @@ void RokiVisualShape::createAsPrimitive(SgMesh* mesh)
     Vector3 p = T0.translation();
 
     switch(mesh->primitiveType()){
-    case SgMesh::BOX : {
-        const Vector3& s = mesh->primitive<SgMesh::Box>().size;
-        zVec3D zp, ax, ay, az;
-        zVec3DCreate(&zp, p.x(), p.y(), p.z());
-        zVec3DCreate(&ax, T0(0,0), T0(1,0), T0(2,0));
-        zVec3DCreate(&ay, T0(0,1), T0(1,1), T0(2,1));
-        zVec3DCreate(&az, T0(0,2), T0(1,2), T0(2,2));
-        zShape3DCreateBox(&shape_, &zp, &ax, &ay, &az,
-                          s.x()*scale.x(), s.y()*scale.y(), s.z()*scale.z());
-        break; }
-    case SgMesh::SPHERE : {
-        SgMesh::Sphere sphere = mesh->primitive<SgMesh::Sphere>();
-        zVec3D zp;
-        zVec3DCreate(&zp, p.x(), p.y(), p.z());
-        zShape3DCreateSphere(&shape_, &zp, sphere.radius*scale.x(), 0);
-        break; }
-    case SgMesh::CYLINDER : {
-        SgMesh::Cylinder cylinder = mesh->primitive<SgMesh::Cylinder>();
-        Vector3 ax(T_(0,0), T_(1,0), T_(2,0));
-        ax *= cylinder.height/2.0 * scale.x();
-        Vector3 c1_ = T0 * ax.cast<Position::Scalar>();
-        Vector3 c2_ = T0 * (-ax).cast<Position::Scalar>();
-        zVec3D c1, c2;
-        zVec3DCreate(&c1, c1_.x(), c1_.y(), c1_.z());
-        zVec3DCreate(&c2, c2_.x(), c2_.y(), c2_.z());
-        zShape3DCreateCyl(&shape_, &c1, &c2, cylinder.radius*scale.x(), 0);
-        break; }
-    case SgMesh::CONE : {
-        SgMesh::Cone cone = mesh->primitive<SgMesh::Cone>();
-        Vector3 ax(T_(0,0), T_(1,0), T_(2,0));
-        ax *= cone.height/2.0 * scale.x();
-        Vector3 c1_ = T0 * ax.cast<Position::Scalar>();
-        Vector3 c2_ = T0 * (-ax).cast<Position::Scalar>();
-        zVec3D c1, c2;
-        zVec3DCreate(&c1, c1_.x(), c1_.y(), c1_.z());
-        zVec3DCreate(&c2, c2_.x(), c2_.y(), c2_.z());
-        zShape3DCreateCone(&shape_, &c1, &c2, cone.radius*scale.x(), 0);
-        break; }
+    case SgMesh::BOX :
+        createAsBox(mesh, T0, p, scale);
+        break;
+    case SgMesh::SPHERE :
+        createAsSphere(mesh, T0, p, scale);
+        break;
+    case SgMesh::CYLINDER :
+        createAsCylinder(mesh, T0, T_, p, scale);
+        break;
+    case SgMesh::CONE :
+        createAsCone(mesh, T0, T_, p, scale);
+        break;
     default:
         cerr << "cannot be created as primitive (type: "
              << mesh->primitiveType() << ")" << endl;
-- 
2.7.4

